**动态链接库**

目标程序通常都不是独立个体，生成程序时都需要链接其他的库，要用到其他库的代码。对于多个程序同时运行而言，[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)中就可能有同一个库的多个副本，占用了太多内存而干的活差不多。

为了优化内存运用效率，引入了[动态链接库](https://so.csdn.net/so/search?q=动态链接库&spm=1001.2101.3001.7020)（Dynamic Link Library），或叫共享库（Shared Object）。使用动态链接库时，内存中只需要一份该库文件，其他程序要使用该库文件时，只要链接过来就行了。由于动态库文件外置，链接到动态库的目标程序相对比较小，因为剥离了大量库代码，而只需要一些链接指针。

使用动态库，也意味着程序需要链接到如 *.dll 或 *.so 文件，得提前装好动态库文件，然后目标程序才能正常运行。

**静态链接库**

静态库就是将链接库的代码和自己编写的代码都编译链接到一块，链接到静态库的程序通常比较大，但好处是运行时依赖的库文件很少，因为目标程序自己内部集成了很多库代码。

**库文件后缀**

Linux/Unix 系统里静态库扩展名一般是 .a，动态库扩展名一般是 .so 。

Windows 系统里 VC 编译器用的静态库扩展名一般是 .lib，动态库扩展名一般是 .dll 。

从本质上来说，由同一段程序编译出来的静态库和动态库，在功能上是没有区别的。不同之处仅仅在于其名字上，也就是“静态”和“动态”。 由上面的介绍不难看出，相对于动态库，静态库的优点在于直接被链接进可执行程序中，之后，该可执行程序就不再依赖于运行环境的设置了（当然仍然会依赖于 CPU指令集和操作系统支持的可执行文件格式等硬性限制）。而动态库的优点在于，用户甚至可以在程序运行时随时替换该动态库，这就构成了动态插件系统的基础。 具体使用静态库和动态库，由程序员根据需要自己决定。

另外，需要说明的一点是，从底层实现上，动态库的效率可能会比静态库稍差一点点，注意，这里用了“可能”二字，具体差不差，还得看写程序的人。之所以可能会差，主要原因在于，程序总无法直接调用动态库中的函数符号，而只能通过调用操作系统的runtime enviroment接口来动态载入某个函数符号，同时获得该函数符号在内存中的地址，将其保存为函数指针进行调用，这就在函数调用时增加了一次间接寻址的过程。



另外，在移植软件的过程中，保持接口不变是有多重含义的，我们通常知道的是：

1. 函数、变量名称不变
2. 函数、变量语法属性不变（比如一个声明为C形式的函数，必须以C形式对其进行调用，否则由于重载特性会找不到函数名）
3. 函数返回值类型不变
4. 函数参数个数不变
5. 函数参数类型不变

这里，常常被人们遗忘的，也是最重要的一点是：

**保持函数语义不变**

这是什么意思，对于一段程序，除了词法分析、语法推导之外，还有很重要的一条就是语义分析。简单来说，对于一个函数，必须保持移植前后，该函数的返回值含义不变、参数含义不变、函数内部行为的外部表现不变。忽视其中任意一条，都会造成上层应用程序的行为变为未定义，从而移植失败。



c语言中存在静态库(.a)和动态库(.so)。

**静态库**实际上是一些目标文件的[集合](https://so.csdn.net/so/search?q=集合&spm=1001.2101.3001.7020)，只用于链接生成可执行文件阶段。链接器会将程序中使用到函数的代码从库文件中拷贝到应用程序中，一旦链接完成生成可执行文件之后，在执行程序的时候就不需要静态库了。

特性：

- 由于每个使用静态库的应用程序都需要拷贝所用函数的代码，所以静态链接的生成的可执行文件会比较大，多个程序运行时占用内存空间比较大(每个程序在内存中都有一份重复的静态库代码)
- 由于运行的时候不用从外部动态加载额外的库了，速度会比共享库快一些
- 更换一个静态库或者修改一个静态库后，需要重新编译应用程序

**动态库**也叫共享库（share object）,在程序链接的时候只是作些标记，然后在程序开始启动运行的时候，动态地加载所需库（模块）。

特性：

- 应用程序在运行的时候需要共享库
- 共享库链接出来的可执行文件比静态库链接出来的要小得多，运行多个程序时占用内存空间比也比静态库方式链接少(因为内存中只有一份共享库代码的拷贝)
- 由于有一个动态加载的过程所以速度稍慢
- 更换动态库不需要重新编译程序，只需要更换相应的库即可

动态库和静态库各有特点，适用于不同的场合。本文主要阐述动态库的使用，重点在于显式运行时链接。